// Code generated by MockGen. DO NOT EDIT.
// Source: eventbus.go

// Package mock_cqrs is a generated GoMock package.
package mock_cqrs

import (
	context "context"
	cqrs "github.com/bounoable/cqrs"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockEventPublisher is a mock of EventPublisher interface
type MockEventPublisher struct {
	ctrl     *gomock.Controller
	recorder *MockEventPublisherMockRecorder
}

// MockEventPublisherMockRecorder is the mock recorder for MockEventPublisher
type MockEventPublisherMockRecorder struct {
	mock *MockEventPublisher
}

// NewMockEventPublisher creates a new mock instance
func NewMockEventPublisher(ctrl *gomock.Controller) *MockEventPublisher {
	mock := &MockEventPublisher{ctrl: ctrl}
	mock.recorder = &MockEventPublisherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEventPublisher) EXPECT() *MockEventPublisherMockRecorder {
	return m.recorder
}

// Publish mocks base method
func (m *MockEventPublisher) Publish(ctx context.Context, events ...cqrs.Event) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range events {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Publish", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockEventPublisherMockRecorder) Publish(ctx interface{}, events ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, events...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventPublisher)(nil).Publish), varargs...)
}

// MockEventSubscriber is a mock of EventSubscriber interface
type MockEventSubscriber struct {
	ctrl     *gomock.Controller
	recorder *MockEventSubscriberMockRecorder
}

// MockEventSubscriberMockRecorder is the mock recorder for MockEventSubscriber
type MockEventSubscriberMockRecorder struct {
	mock *MockEventSubscriber
}

// NewMockEventSubscriber creates a new mock instance
func NewMockEventSubscriber(ctrl *gomock.Controller) *MockEventSubscriber {
	mock := &MockEventSubscriber{ctrl: ctrl}
	mock.recorder = &MockEventSubscriberMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEventSubscriber) EXPECT() *MockEventSubscriberMockRecorder {
	return m.recorder
}

// Subscribe mocks base method
func (m *MockEventSubscriber) Subscribe(ctx context.Context, typ cqrs.EventType) (<-chan cqrs.Event, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, typ)
	ret0, _ := ret[0].(<-chan cqrs.Event)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe
func (mr *MockEventSubscriberMockRecorder) Subscribe(ctx, typ interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventSubscriber)(nil).Subscribe), ctx, typ)
}

// MockEventBus is a mock of EventBus interface
type MockEventBus struct {
	ctrl     *gomock.Controller
	recorder *MockEventBusMockRecorder
}

// MockEventBusMockRecorder is the mock recorder for MockEventBus
type MockEventBusMockRecorder struct {
	mock *MockEventBus
}

// NewMockEventBus creates a new mock instance
func NewMockEventBus(ctrl *gomock.Controller) *MockEventBus {
	mock := &MockEventBus{ctrl: ctrl}
	mock.recorder = &MockEventBusMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEventBus) EXPECT() *MockEventBusMockRecorder {
	return m.recorder
}

// Publish mocks base method
func (m *MockEventBus) Publish(ctx context.Context, events ...cqrs.Event) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx}
	for _, a := range events {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Publish", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockEventBusMockRecorder) Publish(ctx interface{}, events ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx}, events...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockEventBus)(nil).Publish), varargs...)
}

// Subscribe mocks base method
func (m *MockEventBus) Subscribe(ctx context.Context, typ cqrs.EventType) (<-chan cqrs.Event, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", ctx, typ)
	ret0, _ := ret[0].(<-chan cqrs.Event)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe
func (mr *MockEventBusMockRecorder) Subscribe(ctx, typ interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockEventBus)(nil).Subscribe), ctx, typ)
}
